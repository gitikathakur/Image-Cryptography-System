# -*- coding: utf-8 -*-
"""Quadra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10ofeba6I8kH434s4OCc1krcx0hAGYsNX
"""

import cv2
import numpy as np
import random
import PIL
from PIL import Image
import numpy as np
import os
from matplotlib.pyplot import imshow
import matplotlib.pyplot as plt
import cv2
import random
from math import log
from google.colab.patches import cv2_imshow
from tqdm import tqdm
import warnings
warnings.filterwarnings("ignore")

BASEIMAGE = 'BASE IMAGE'
EXTENSIONBASE = '.jpg'
TARGETIMAGE = 'TARGET IMAGE'
EXTENSIONTARGET = '.jpg'

def getImageMatrix(image,extension):
  im = Image.open(image+extension).convert('LA')
  pix = im.load()
  image_size = im.size
  image_matrix = []
  for width in range(int(image_size[0])):
    row = []
    for height in range(int(image_size[1])):
      row.append((pix[width,height]))
      image_matrix.append(row)
    return image_matrix, image_size[0], image_size[1]

def autoCorrelation(image,extension):
  ImageMatrix,image_size = getImageMatrix_gray(image,extension)
  samples_x = []
  samples_y = []
  for i in range(1024):
    x = random.randint(0,image_size-2)
    y = random.randint(0,image_size-1)
    samples_x.append(ImageMatrix[x][y])
    samples_y.append(ImageMatrix[x+1][y])
  plt.figure(figsize=(10,8))
  plt.scatter(samples_x,samples_y,s=2)
  plt.title('Adjacent Pixel Autocorrelation - Original Image', fontsize=20)

img = Image.open(TARGETIMAGE+EXTENSIONTARGET)
img

img = Image.open(BASEIMAGE+EXTENSIONBASE)
img

#@title Henon Map Encryption
def henonMapEnc(image,extension,x0,y0):
    im = Image.open(image+extension)
    px = im.load()
    w, h = im.size

    a = 1.4
    b = 0.3
    ncoords = []

    for i in range(0, h * w):   #loop iterates over each pixel
        x = 1 - 1.4 * pow(x0, 2) + y0   #new coordinates of pixel using henon map
        y = 0.3 * x0    #new coordinates of pixel using henon map

          #new coordinates are added to ncoords list
        xr = int(('%.12f' % (x))[5:9]) % w

        #takeing 5th to 9th dight of integer part to get new integer
        yr = int(('%.12f' % (y))[5:9]) % h

        ncoords.append((xr, yr))#This line adds the new (x,y) coordinates of
        #the current pixel to the ncoords list
        x0 = float('%.14f' % (x))
        y0 = float('%.14f' % (y))

    ncoords.reverse()

    for i in range(0, h * w):
        (xr, yr) = ncoords[i]#retrives new x,y corrdinate
        j = h * w - i - 1#computes the index of the pixel in the encrypted image
        (xr, yr) = ncoords[i]

        j = h * w - i - 1
        #This line retrieves the original pixel value at the index j

        p = px[j % w, int(j / w)]
        #This line retrieves the new pixel value at the (x,y)

        pr = px[xr, yr]
        px[j % w, int(j / w)] = pr
        px[xr, yr] = p

    im.save('encrypted_target.png')

ENCRYPTEDIMAGE = 'encrypted_target'
EXTENSIONENCRYPTED = '.png'

#@title HENON MAP DECRYPTION
def henonMapDec(image,extension,x0,y0):
    im = Image.open(image+extension)
    px = im.load()
    w, h = im.size

    #y0 = 0.11
    #x0 = 0.1
    """
    Flattening to linear using one loop
    """
    for i in range(0, h * w):
        x = 1 - 1.4 * pow(x0, 2) + y0
        y = 0.3 * x0
        x0 = float('%.14f' % (x))
        y0 = float('%.14f' % (y))
        xr = int(('%.11f' % (x))[5:9]) % w
        yr = int(('%.11f' % (y))[5:9]) % h

        p = px[i % w, int(i / w)]
        pr = px[xr, yr]
        px[i % w, int(i / w)] = pr
        px[xr, yr] = p

    im.save('decrypted_target.png', progressive=False, quality=100)

DECRYPTEDIMAGE = 'decrypted_target'
EXTENSIONDECRYPTED = '.png'

henonMapEnc(TARGETIMAGE, EXTENSIONTARGET, 0.21, 0.3201)

img = Image.open(ENCRYPTEDIMAGE+EXTENSIONENCRYPTED)
img

def hide(image,extension):
# img1 and img2 are the
# two input images
  img1 = cv2.imread(image+extension) #IMAGE TO HIDE IN
  #img1 = cv2.cvtColor(img1,cv2.COLOR_BGR2RGB)
  img2 = cv2.imread('encrypted_target.png') #IMAGE TO HIDE
  #img2 = cv2.cvtColor(img2,cv2.COLOR_BGR2RGB)
  for i in range(img2.shape[0]):
    for j in range(img2.shape[1]):
      for l in range(3):
				# v1 and v2 are 8-bit pixel values
				# of img1 and img2 respectively
        v1 = format(img1[i][j][l], '08b')
        v2 = format(img2[i][j][l], '08b')

				# Taking 4 MSBs of each image
        v3 = v1[:4] + v2[:4]

        img1[i][j][l]= int(v3, 2)
  cv2.imwrite('steg.png', img1)

COMBINEDIMAGE = 'steg'
EXTENSIONCOMBINED = '.png'

hide(BASEIMAGE, EXTENSIONBASE)

img = Image.open(BASEIMAGE+EXTENSIONBASE)
img

img = Image.open(COMBINEDIMAGE+EXTENSIONCOMBINED)
img

# Decryption function
def reveal(extensionBase, extensionTarget):
	# Encrypted image
  img = cv2.imread('steg.png')
  #img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
  width = img.shape[0]
  height = img.shape[1]
	# img1 and img2 are two blank images
  img1 = np.zeros((width, height, 3), np.uint8)
  img2 = np.zeros((width, height, 3), np.uint8)
  for i in range(width):
    for j in range(height):
      for l in range(3):
        v1 = format(img[i][j][l], '08b')
        v2 = v1[:4] + chr(random.randint(0, 1)+48) * 4
        v3 = v1[4:] + chr(random.randint(0, 1)+48) * 4

				# Appending data to img1 and img2
        img1[i][j][l]= int(v2, 2)
        img2[i][j][l]= int(v3, 2)

	# These are two images produced from
	# the encrypted image
  cv2.imwrite('Base_re.png', img1)
  cv2.imwrite('Target_re.png', img2)

FINALBASE= 'Base_re'
FINALEXTENSION='.png'
FINALTARGET= 'Target_re'

reveal(EXTENSIONBASE, EXTENSIONTARGET)

img = Image.open(FINALBASE+FINALEXTENSION)
img

img = Image.open(FINALTARGET+FINALEXTENSION)
img

henonMapDec(FINALTARGET, FINALEXTENSION, 0.21, 0.3200)

img = Image.open(DECRYPTEDIMAGE+EXTENSIONDECRYPTED)
img

henonMapDec(FINALTARGET, FINALEXTENSION, 0.21, 0.3201)

img = Image.open(DECRYPTEDIMAGE+EXTENSIONDECRYPTED)
img